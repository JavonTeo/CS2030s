package cs2030s.fp;

import java.util.ArrayList;
import java.util.List;
import java.util.NoSuchElementException;
/**
 * A list with a possible infinite number
 * of elements, build using Lazy evaluation.
 *
 * @author A0233706J (Lab 14J)
 * @version CS2030S AY 21/22 Sem 2
 */

public class InfiniteList<T> {
  /** The Lazy wrapper containing the Maybe wrapper containing the head of the InfiniteList. */
  private final Lazy<Maybe<T>> head;

  /** The Lazy wrapper containing the tail of the InfiniteList. */
  private final Lazy<InfiniteList<T>> tail;

  /** The single instance of the sentinel. */
  private static final Sentinel SENTINEL = new Sentinel();

  /**
   * A private constructor to intialize the empty InfiniteList.
   */
  private InfiniteList() { 
    this.head = null; 
    this.tail = null;
  }
  
  /**
   * Creates an InfiniteList where each element is generated by the provided Producer.
   *
   * @param <T> The type of the value produced by the Producer.
   * @param producer The Producer used to generate each element of the created InfiniteList.
   * @return The InfiniteList created.
   */
  public static <T> InfiniteList<T> generate(Producer<T> producer) {
    // TODO
    return new InfiniteList<T>(Lazy.of(() -> Maybe.some(producer.produce())),
        Lazy.of(() -> InfiniteList.generate(producer)));
  }

  /**
   * Creates an InfiniteList produced by iterative application of the provided
   * Transformer to the initial given element seed.
   *
   * @param <T> The type of the seed.
   * @param seed The initial element.
   * @param next The Transformer to be applied to the previous element to produce a new element.
   * @return The InfiniteList created.
   */
  public static <T> InfiniteList<T> iterate(T seed, Transformer<T, T> next) {
    // TODO
    return new InfiniteList<T>(Lazy.of(Maybe.some(seed)),
        Lazy.of(() -> InfiniteList.iterate(next.transform(seed), next)));
  }

  /**
   * A private constructor to intialize the InfiniteList
   * with the head value and the Producer wrapper
   * to produce the tail.
   *
   * @param head The given head value to wrap around.
   * @param tail The producer wrapper to produce the tail.
   */
  private InfiniteList(T head, Producer<InfiniteList<T>> tail) {
    // TODO
    this.head = Lazy.of(Maybe.of(head));
    this.tail = Lazy.of(tail);
  }

  /**
   * A private constructor to intialize the InfiniteList
   * with the Lazy wrapper containing the head value
   * and the Lazy wrapper containing the tail.
   *
   * @param head The Lazy wrapper containing the head value.
   * @param tail The Lazy wrapper containing the tail.
   */
  private InfiniteList(Lazy<Maybe<T>> head, Lazy<InfiniteList<T>> tail) {
    // TODO
    this.head = head;
    this.tail = tail;
  }

  /**
   * Returns the evaluated head of the InfiniteList.
   *
   * @return The head value.
   */
  public T head() {
    // TODO
    return this.head.get().orElseGet(() -> this.tail.get().head());
  }

  /**
   * Returns the evaluated tail of the InifiniteList.
   *
   * @return The tail value.
   */
  public InfiniteList<T> tail() {
    // TODO
    return this.head.get().map(x -> this.tail.get()).orElseGet(() -> this.tail.get().tail());
  }

  /**
   * Lazily applies the transformation given by the Transformer
   * to each element in the list.
   *
   * @param <R> The type of the list elements after transformation.
   * @param mapper The Transformer that transforms each element of the list.
   * @return The resulting transformed InfiniteList.
   */
  public <R> InfiniteList<R> map(Transformer<? super T, ? extends R> mapper) {
    // TODO
    return new InfiniteList<R>(Lazy.of(() -> Maybe.some(mapper.transform(this.head()))),
          Lazy.of(() -> this.tail().map(mapper)));
  }

  /**
   * Filter out elements in the list that fail the given BooleanCondition.
   *
   * @param predicate The BooleanCondition used to check if the list passes the BooleanCondition.
   * @return The filtered InfiniteList.
   */
  public InfiniteList<T> filter(BooleanCondition<? super T> predicate) {
    // TODO
    Producer<Maybe<T>> newHead = () -> this.head.get().filter(predicate);
    return new InfiniteList<T>(Lazy.of(newHead),
          Lazy.of(() -> this.tail.get().filter(predicate)));
  }

  /**
   * A special tail to mark the end of the finite list.
   */
  private static class Sentinel extends InfiniteList<Object> {
    /**
     * Return the string representation of the InfiniteList.
     *
     * @return The string representation of the InfiniteList.
     */
    @Override
    public String toString() {
      String s = String.format("-");
      return s;
    }

    /**
     * Checks if the list is an instance of Sentinel.
     *
     * @return The resulting boolean value of whether it is a sentinel.
     */
    public boolean isSentinel() {
      return this instanceof Sentinel;
    }

    /**
     * Filter out elements in the list that fail the given BooleanCondition.
     *
     * @param bC The BooleanCondition used to check if the list passes the BooleanCondition.
     * @return The filtered InfiniteList.
     */
    @Override
    public InfiniteList<Object> filter(BooleanCondition<? super Object> bC) {
      return InfiniteList.sentinel();
    }

    /**
     * Lazily applies the transformation given by the Transformer
     * to each element in the list.
     *
     * @param <S> The type of the list elements after transformation.
     * @param tr The Transformer that transforms each element of the list.
     * @return The resulting transformed InfiniteList.
     */
    @Override
    public <S> InfiniteList<S> map(Transformer<? super Object, ? extends S> tr) {
      return InfiniteList.sentinel();
    }

    /**
     * Truncates the InfiniteList to a finite list with the given number of elements.
     *
     * @param n The number of elements the resulting list should have.
     * @return The resulting finite list.
     */
    @Override
    public InfiniteList<Object> limit(long n) {
      return InfiniteList.sentinel();
    }

    /**
     * Returns the evaluated head of the InfiniteList.
     *
     * @return The head value.
     */
    @Override
    public Object head() throws NoSuchElementException {
      throw new NoSuchElementException();
    }

    /**
     * Returns the evaluated tail of the InifiniteList.
     *
     * @return The tail value.
     */
    @Override
    public InfiniteList<Object> tail() throws NoSuchElementException {
      throw new NoSuchElementException();
    }

    /**
     * Truncates the list up till the element that fails the BooleanCondition.
     *
     * @param predicate The BooleanCondition to test the elements of the InfiniteList.
     * @return The resulting InfiniteList.
     */
    @Override
    public InfiniteList<Object> takeWhile(BooleanCondition<? super Object> predicate) {
      return InfiniteList.sentinel();
    }

    /**
     * Performs a reduction on the elements of the InfiniteList.
     *
     * @param <U> The type of the element after transformation.
     * @param identity The starting value for the reduction process.
     * @param accumulator The Combiner that combines the elements of the InfiniteList.
     * @return The result of the reduction.
     */
    @Override
    public <U> U reduce(U identity, Combiner<U, ? super Object, U> accumulator) {
      return identity;
    }

    /**
     * Returns the count of elements in the InfiniteList.
     *
     * @return The count of elements in the InfiniteList.
     **/
    @Override
    public long count() {
      return 0L;
    }
  }

  /**
   * Returns a sentinel.
   *
   * @param <T> The type of the sentinel.
   * @return The InfiniteList.SENTINEL;
   */
  public static <T> InfiniteList<T> sentinel() {
    // TODO
    @SuppressWarnings("unchecked")
    InfiniteList<T> sen = (InfiniteList<T>) InfiniteList.SENTINEL;
    return sen;
  }

  /**
   * Truncates the InfiniteList to a finite list with the given number of elements.
   *
   * @param n The number of elements the resulting list should have.
   * @return The resulting finite list.
   */
  public InfiniteList<T> limit(long n) {
    // TODO
    if (n <= 0) {
      return InfiniteList.sentinel();
    } else {
      return new InfiniteList<T>(this.head,
          Lazy.of(() -> this.head.get().map(x -> this.tail.get().limit(n - 1))
            .orElseGet(() -> this.tail.get().limit(n))));
    }
  }

  /**
   * Truncates the list up till the element that fails the BooleanCondition.
   *
   * @param predicate The BooleanCondition to test the elements of the InfiniteList.
   * @return The resulting InfiniteList.
   */
  public InfiniteList<T> takeWhile(BooleanCondition<? super T> predicate) {
    // TODO
    Lazy<Maybe<T>> lm = Lazy.of(() -> Maybe.some(this.head()).filter(predicate));
    return new InfiniteList<T>(lm,
        Lazy.of(() -> lm.get().map(x -> this.tail().takeWhile(predicate))
          .orElseGet(() -> InfiniteList.sentinel())));
  }

  /**
   * Checks if the list is an instance of Sentinel.
   *
   * @return The resulting boolean value of whether it is a sentinel.
   */
  public boolean isSentinel() {
    return false;
  }

  /**
   * Performs a reduction on the elements of the InfiniteList.
   *
   * @param <U> The type of the element after transformation.
   * @param identity The starting value for the reduction process.
   * @param accumulator The Combiner that combines the elements of the InfiniteList.
   * @return The result of the reduction.
   */
  public <U> U reduce(U identity, Combiner<U, ? super T, U> accumulator) {
    // TODO
    Maybe<U> accumulated = this.head.get().map(x -> accumulator.combine(identity, x));
    return accumulated.map(x -> this.tail.get().reduce(x, accumulator))
      .orElse(this.tail.get().reduce(identity, accumulator));
  }

  /**
   * Returns the count of elements in the InfiniteList.
   *
   * @return The count of elements in the InfiniteList.
   **/
  public long count() {
    // TODO
    Long accum = 0L;
    return this.reduce(accum, (x, y) -> x + 1);
  }

  /**
   * Collects the elements in the InfiniteList into a java.util.List.
   *
   * @return The new List containing the collected elements.
   **/
  public List<T> toList() {
    // TODO
    ArrayList<T> arrL = new ArrayList<T>();
    InfiniteList<T> curr = this;
    while (!curr.isSentinel()) {
      curr.head.get().map(x -> arrL.add(x));
      curr = curr.tail.get();
    }
    return arrL;
  }

  /**
   * Return the string representation of the InfiniteList.
   *
   * @return The string representation of the InfiniteList.
   */
  public String toString() {
    return "[" + this.head + " " + this.tail + "]";
  }
}
